
package main

import (
	"fmt"
	"os"
	"strings"
)

var Up string = "^"
var Right string = ">"
var Down string = "v"
var Left string = "<"

type Node struct {
	x   int
	y   int
	val string
}

type NodeArray []Node

type Karta []NodeArray

/*


....#.....
.........#
..........
..#.......
.......#..
..........
.#..^.....
........#.
#.........
......#...


*/

func main() {
	karta := makeMap()

	// guardPos := karta.guardPosition()

	// guard := makeGuard(guardPos)

	// karta.Print()
	// karta.guardPosition()
	// karta.PrintRaw()

	for i := 0; i < 10; i++ {
		karta.Move()
	}

	karta.Print()

}

// func makeGuard(guardPos Node) Guard {
//
// guard := Guard{
// pos:    guardPos,
// facing: guardPos.val,
// }
//
// return guard
//
// }

func (k Karta) Move() {

	current := k.guardPosition()

	x := current.x
	y := current.y

	// if we CAN go up
	if current.val == Up && k[x-1][y].val != "#" {
		k[x-1][y].val = "^"
		k[x][y].val = "X"
	}

	// if we CAN'T go up
	if current.val == "^" && k[x-1][y].val == "#" {
		k[x][y].val = ">"
	}

	// if we CAN go right
	if current.val == Right && k[x][y+1].val != "#" {
		k[x][y+1].val = ">"
		k[x][y].val = "X"
	}

	// if we CAN'T go right
	if current.val == ">" {
		fmt.Println("We are here", k[x][y])
		k[1][7+1].val = "v"
	}

	// if current.val == ">" && k[x][y+1].val == "#" {
	// k[x][y].val = "v"
	// }

	// // if we CAN go down
	// if current.val == Right && k[x][y+1].val != "#" {
	// k[x][y+1].val = Right
	// k[x][y].val = "X"
	// }

}

func (k Karta) Print() {
	for i := range k {
		for _, j := range k[i] {
			fmt.Print(j.val)
		}
		fmt.Println("")
	}
}

func (k Karta) PrintRaw() {
	for i := range k {
		fmt.Println(k[i])
	}
}

func (k Karta) guardPosition() Node {
	for i := range k {
		for _, j := range k[i] {
			if j.val == "^" || j.val == ">" || j.val == "v" || j.val == "<" {
				fmt.Printf(" \nThe guard is at X:%d Y:%d, facing %s\n\n", j.x, j.y, j.val)
				return j
			}
		}
	}
	return Node{x: 0, y: 0, val: "."}
}

func makeMap() Karta {
	rawMap, err := os.ReadFile("./map.txt")
	handleError(err)

	var result Karta

	stringLine := strings.Split(strings.TrimRight(string(rawMap), "\n\n"), "\n")

	for i := 0; i < len(stringLine); i++ {

		var line NodeArray
		var newNode Node
		for j := 0; j < len(stringLine); j++ {
			newNode.x = i
			newNode.y = j
			newNode.val = string(stringLine[i][j])
			line = append(line, newNode)
		}
		result = append(result, line)
	}

	return result
}
